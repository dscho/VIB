/**
 * 
 */
package nrrd;

import ij.io.FileInfo;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

/**
 * This class contains the key information that describes a nrrd file
 * The expectation is that it will be generated by parsing an existing file
 * before loading.  It will also be generated before saving a file.
 * It should be handed off to NrrdFile reader/writer in order to save/load
 * It is conceptually similar to ImageJ's FileInfo class, but I have decided
 * not to derive it from that because I would like to make this package
 * detachable from ImageJ.
 * @author jefferis
 *
 */
public class NrrdInfo {
	/**
	 * @author jefferis
	 *
	 */
	
	public static final int NRRD_DIM_MAX = 16;
	public static final int NRRD_SPACE_DIM_MAX = 8;
	int type;
	int dim=-1;
	Object[] data;
	NrrdAxisInfo[] nai=new NrrdAxisInfo[NRRD_DIM_MAX];
	
	String content,sampleUnits;
	String contentType; // gj - my own
	int space; // ->string?
	String[] spaceUnits = new String[NRRD_SPACE_DIM_MAX];
	double[] spaceOrigin = new double[NRRD_SPACE_DIM_MAX];
	double[][] measurementFrame = new double[NRRD_SPACE_DIM_MAX][NRRD_SPACE_DIM_MAX];
	double oldMin,oldMax;
	
	
	public final String int8Types="char, signed char, int8, int8_t";
	public final String[] int8 = {"char","signed char", "int8", "int8_t"};
//	List mylist = Arrays.asList(int8Types.split(", "));
	List mylist = Arrays.asList(int8);
	boolean x= mylist.contains("char");
	
	public final String uint8Types="uchar, unsigned char, uint8, uint8_t";
	public final String int16Types="short, short int, signed short, signed short int, int16, int16_t";
	public final String uint16Types="ushort, unsigned short, unsigned short int, uint16, uint16_t";
	public final String int32Types="int, signed int, int32, int32_t";
	public final String uint32Types="uint, unsigned int, uint32, uint32_t";
	public final String int64Types="longlong, long long, long long int, signed long long, signed long long int, int64 int64_t";
	public final String uint64Types="ulonglong, unsigned long long, unsigned long long int, uint64, uint64_t";
	
	public static final int NRRD_TYPE_DEFAULT=0;
	public static final int NRRD_TYPE_CHAR=1;         
	public static final int NRRD_TYPE_UCHAR=2;         
	public static final int NRRD_TYPE_SHORT=3;     
	public static final int NRRD_TYPE_USHORT=4;        
	public static final int NRRD_TYPE_INT=5;       
	public static final int NRRD_TYPE_UINT=6;         
	public static final int NRRD_TYPE_LLONG=7;        
	public static final int NRRD_TYPE_ULLONG=8;       
	public static final int NRRD_TYPE_FLOAT=9;      
	public static final int NRRD_TYPE_DOUBLE=10;       
	public static final int NRRD_TYPE_BLOCK=11;     
	public static final int NRRD_TYPE_LAST=12;
	
//	String getStandardType(String stype) throws Exception{
//		
//		if (uint8Types.indexOf(stype)>=0) {
//			return 
//		} else if(uint16Types.indexOf(type)>=0) {
//			fi.fileType=FileInfo.GRAY16_SIGNED;
//		} else if(int16Types.indexOf(type)>=0) {
//			fi.fileType=FileInfo.GRAY16_UNSIGNED;
//		} else if(uint32Types.indexOf(type)>=0) {
//			fi.fileType=FileInfo.GRAY32_UNSIGNED;
//		} else if(int32Types.indexOf(type)>=0) {
//			fi.fileType=FileInfo.GRAY32_INT;
//		} else if(type.equals("float")) {
//			fi.fileType=FileInfo.GRAY32_FLOAT;
//		} else if(type.equals("double")) {
//			fi.fileType=FileInfo.GRAY64_FLOAT;
//		} else {
//			throw new Exception("Unimplemented data type ="+type);
//		}
//	}
	
	// this will contain the basic info
	NrrdHeader nh;
	
	/**
	 * @param args
	 */
	
	public NrrdInfo(NrrdHeader nh){
		this.nh=nh;
	}
	String[] getStringField(String key){
		if(nh.fields.containsKey(key)){
			return (String[]) nh.fields.get(key);
		} else return null;
	}
	
	String[] getStringFieldChecked(String key, int n) throws Exception {
		String[] sa;
		sa=getStringField(key);
		if(sa==null || sa.length!=n) throw new Exception("Field: "+key+" must have excatly "+n+" values");
		return sa;
	}
	 
	double[] getDoubleField(String key){
		if(nh.fields.containsKey(key)){
			String[] sa=(String[]) nh.fields.get(key);
			double[] da=new double[sa.length];
			for(int i=0;i<sa.length;i++){
				da[i] = new Double(sa[i]).doubleValue();
			}
			return da;
		} else return null;
	}

	long[] getLongField(String key){
		if(nh.fields.containsKey(key)){
			String[] sa=(String[]) nh.fields.get(key);
			long[] la=new long[sa.length];
			for(int i=0;i<sa.length;i++){
				la[i] = new Long(sa[i]).longValue();
			}
			return la;
		} else return null;
	}
	int[] getIntegerField(String key){
		if(nh.fields.containsKey(key)){
			String[] sa=(String[]) nh.fields.get(key);
			int[] ia=new int[sa.length];
			for(int i=0;i<sa.length;i++){
				ia[i] = new Integer(sa[i]).intValue();
			}
			return ia;
		} else return null;
	}

	int[] getIntegerFieldChecked(String key, int n) throws Exception {
		int[] ia;
		ia=getIntegerField(key);
		if(ia==null || ia.length!=n) throw new Exception("Field: "+key+" must have excatly "+n+" values");
		return ia;
	}
	
	void parseHeader() throws Exception {
		try{
		String[] sa;
		int[] ia;
		double[] da;
		
		dim=getIntegerFieldChecked("dimension", 1)[0];
		if(dim<1 || dim>NRRD_DIM_MAX) throw new Exception("dim out of range:"+dim);
		
		String typeStr=getStringFieldChecked("type",1)[0];
		
		if(sa!=null && sa.length==1) dim=new Integer(sa[0].toString()).intValue();
		} catch (Exception e){
			throw new Exception ("nrrd: trouble parsing header for field: "+e);
		}
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

class NrrdAxisInfo {
	int size;
	double spacing;
	double min, max;
	double[] spaceDirection=new double[NrrdInfo.NRRD_SPACE_DIM_MAX];
	int center;
	int kind;
	String label,units;
}